from database import add_record
from datetime import date
from aiogram import Router, F
from aiogram.types import Message, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from aiogram.fsm.context import FSMContext
from states import RecordStates


router = Router()

INCOME_CATS = {
    "–ü—Ä–æ–¥–∞–∂–∏": [],
    "–°—Ç–∏–ø–µ–Ω–¥–∏—è": [],
    "–ü–æ–¥–∞—Ä–∫–∏": [],
    "–ó–∞—Ä–ø–ª–∞—Ç–∞": ["–ù–∞–ª–∏—á–Ω—ã–µ", "–ö–∞—Ä—Ç–∞"]
}

EXPENSE_CATS = {
    "–ï–¥–∞": [],
    "–ñ–∏–ª—å–µ": [],
    "–†–∞–∑–≤–ª–µ—á–µ–Ω–∏—è": [],
    "–ó–¥–æ—Ä–æ–≤—å–µ": [],
    "–ü–æ–¥–∞—Ä–∫–∏": [],
    "–¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç": ["–¢–∞–∫—Å–∏", "–û–±—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç"]
}

def make_inline_cats(type_str):
    kb = []
    cats = INCOME_CATS if type_str == "income" else EXPENSE_CATS
    for c in cats:
        kb.append([InlineKeyboardButton(text=c, callback_data=f"rec_cat|{c}")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

def make_inline_subs(cat):
    kb = []
    parent = {**INCOME_CATS, **EXPENSE_CATS}
    for s in parent.get(cat, []):
        kb.append([InlineKeyboardButton(text=s, callback_data=f"rec_sub|{s}")])
    return InlineKeyboardMarkup(inline_keyboard=kb)

@router.message(F.text == "‚ûï –î–æ—Ö–æ–¥")
async def inc_start(msg: Message, state: FSMContext):
    await state.clear()
    await state.update_data(type="income")
    await msg.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup=make_inline_cats("income"))
    await state.set_state(RecordStates.waiting_for_category)


@router.message(F.text == "‚ûñ –†–∞—Å—Ö–æ–¥")
async def exp_start(msg: Message, state: FSMContext):
    await state.clear()
    await state.update_data(type="expense")
    await msg.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é:", reply_markup=make_inline_cats("expense"))
    await state.set_state(RecordStates.waiting_for_category)


@router.callback_query(F.data.startswith("rec_cat|"))
async def cat_chosen(call: CallbackQuery, state: FSMContext):
    cat = call.data.split("|")[1]
    await state.update_data(category=cat)
    await call.message.delete()

    parent = {**INCOME_CATS, **EXPENSE_CATS}
    if parent.get(cat):
        await call.message.answer(
            "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–¥–∫–∞—Ç–µ–≥–æ—Ä–∏—é:",
            reply_markup=make_inline_subs(cat)
        )
        await state.set_state(RecordStates.waiting_for_subcategory)
    else:
        await call.message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É:")
        await state.set_state(RecordStates.waiting_for_amount)


@router.callback_query(F.data.startswith("rec_sub|"))
async def sub_chosen(call: CallbackQuery, state: FSMContext):
    sub = call.data.split("|")[1]
    await state.update_data(subcategory=sub)
    await call.message.delete()

    await call.message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É:")
    await state.set_state(RecordStates.waiting_for_amount)


@router.message(RecordStates.waiting_for_amount)
async def amount(msg: Message, state: FSMContext):
    try:
        amt = float(msg.text.replace(",", "."))
    except ValueError:
        return await msg.answer("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ, –Ω–∞–ø—Ä–∏–º–µ—Ä: 1500")

    data = await state.get_data()

    add_record(
        data["type"],
        data["category"],
        data.get("subcategory"),
        amt,
        date.today().isoformat()
    )

    await msg.answer(
        f"‚úÖ –ó–∞–ø–∏—Å—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞\n"
        f"üìÖ {date.today().isoformat()}\n"
        f"üí∞ {amt}"
    )

    await state.clear()
